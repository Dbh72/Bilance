<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bilancia Algebrica con Equazione Assegnata</title>
    <!-- Carica Tailwind CSS per lo stile -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Carica i moduli React e ReactDOM da CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Carica Babel per compilare JSX nel browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Carica MathJax per il rendering LaTeX -->
    <script type="text/javascript" id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        .font-inter {
            font-family: 'Inter', sans-serif;
        }
        /* Nuova sfumatura di sfondo per l'intero corpo, da rosa chiaro a rosa più scuro */
        body {
            @apply bg-gradient-to-br from-rose-50 to-rose-200;
        }

        .balance-container {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            width: 100%;
            max-width: 900px;
            height: 280px;
            position: relative;
            margin-bottom: 4rem;
        }
        /* Colori aggiornati per il perno della bilancia */
        .pivot-base {
            width: 100px;
            height: 30px;
            background-color: #A0522D; /* Colore marrone */
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 10px;
            z-index: 0;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .pivot {
            width: 40px;
            height: 180px;
            background-color: #D2691E; /* Colore marrone scuro */
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 0 0 20px 20px;
            z-index: 1;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .beam {
            width: 100%;
            height: 30px;
            background-color: #CD853F; /* Colore marrone chiaro */
            position: absolute;
            top: 55px;
            left: 0;
            right: 0;
            margin: auto;
            border-radius: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 5%;
            box-shadow: inset 0 3px 6px rgba(0,0,0,0.2);
            transition: transform 0.5s ease-in-out;
            transform-origin: center 15px;
            /* Use CSS variable for the base transform value */
            transform: rotate(var(--current-tilt, 0deg));
        }
        /* Jiggle animation */
        @keyframes jiggle {
            0% { transform: rotate(var(--current-tilt, 0deg)); }
            25% { transform: rotate(calc(var(--current-tilt, 0deg) + 1deg)); }
            50% { transform: rotate(calc(var(--current-tilt, 0deg) - 1deg)); }
            75% { transform: rotate(calc(var(--current-tilt, 0deg) + 0.5deg)); }
            100% { transform: rotate(var(--current-tilt, 0deg)); }
        }
        .beam.jiggle-animation {
            animation: jiggle 0.3s ease-out;
        }

        .plate-holder {
            width: 280px;
            height: 180px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: flex-end;
        }
        /* Colore del piatto aggiornato a una tonalità crema chiara */
        .plate {
            width: 260px;
            min-height: 120px;
            background-color: #FDF9F3; /* Colore crema/panna */
            border: 4px solid #8B4513;
            border-radius: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
            padding: 15px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }
        .item-block {
            min-width: 60px;
            min-height: 50px;
            max-width: 100%;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: black;
            font-weight: 700;
            border-radius: 8px;
            margin: 5px;
            box-shadow: 0 3px 6px rgba(0,0,0,0.2);
            position: relative;
            padding: 5px;
            overflow: hidden;
            word-break: break-word;
        }
        /* Colori aggiornati per i termini, tutti nella tonalità del rosa */
        .item-block.positive {
            background-color: #F8BBD0; /* Rosa chiaro */
        }
        .item-block.negative {
            background-color: #E91E63; /* Rosa scuro/Fucsia */
            color: white; /* Per una migliore leggibilità */
        }
        .item-block.variable {
            background-color: #FFECB3; /* Giallo chiaro per contrasto */
        }
        .control-section {
            @apply bg-rose-50 p-6 rounded-xl shadow-lg mb-6 w-full max-w-md;
        }
        .control-section h3 {
            @apply text-xl font-bold text-gray-700 mb-4;
        }
        .control-section input {
            @apply p-2 border border-rose-300 rounded-md w-full mb-3 focus:ring-2 focus:ring-rose-400;
        }
        /* Colori dei pulsanti aggiornati con sfumature di rosa/rosso */
        .control-section button {
            @apply bg-rose-200 hover:bg-rose-300 text-black font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105;
        }
        .control-section button:disabled {
            @apply bg-gray-400 cursor-not-allowed;
        }
        /* Stile specifico per i pulsanti Moltiplica/Dividi */
        .control-section .grid button {
            @apply bg-rose-200 hover:bg-rose-300 text-black;
        }

        /* General styling for fraction display */
        .flex-col .text-sm {
            font-size: 0.9rem;
        }
        .flex-col .text-black {
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // --- Funzioni di Utilità per l'Aritmetica delle Frazioni ---

        // Massimo Comun Divisore (MCD) usando l'algoritmo di Euclide
        const gcd = (a, b) => {
            a = Math.abs(a);
            b = Math.abs(b);
            while (b) {
                [a, b] = [b, a % b];
            }
            return a;
        };

        // Semplifica una frazione {numeratore, denominatore, segno}
        const simplifyFraction = (fraction) => {
            if (fraction.numerator === 0) {
                return { numerator: 0, denominator: 1, sign: 1 };
            }
            const common = gcd(fraction.numerator, fraction.denominator);
            return {
                numerator: fraction.numerator / common,
                denominator: fraction.denominator / common,
                sign: fraction.sign // Mantieni il segno originale
            };
        };

        // Funzione di utilità per sommare due frazioni
        const addFractions = (f1, f2) => {
            // Assicura che le frazioni siano in un formato consistente (numeratore/denominatore positivi, segno applicato esternamente)
            const n1 = f1.numerator * f1.sign;
            const d1 = f1.denominator;
            const n2 = f2.numerator * f2.sign;
            const d2 = f2.denominator;

            const num = (n1 * d2) + (n2 * d1);
            const den = d1 * d2;

            let sign = 1;
            if (num < 0) { sign = -1; }
            const simplified = simplifyFraction({ numerator: Math.abs(num), denominator: den, sign: sign });
            return simplified;
        };

        // Funzione di utilità per dividere due frazioni
        const divideFractions = (f1, f2) => {
            if (f2.numerator === 0) {
                // Questo caso dovrebbe essere gestito prima di chiamare divideFractions per la soluzione.
                // Per ora, restituisce un valore speciale o lancia un errore.
                return { error: 'Divisione per zero nella divisione di frazioni.' };
            }
            const n1 = f1.numerator * f1.sign;
            const d1 = f1.denominator;
            const n2 = f2.numerator * f2.sign;
            const d2 = f2.denominator;

            const num = n1 * d2;
            const den = d1 * n2;

            let sign = 1;
            if (num < 0) { sign = -1; }
            if (den < 0) { sign *= -1; } // Regola il segno se il denominatore è negativo
            const simplified = simplifyFraction({ numerator: Math.abs(num), denominator: Math.abs(den), sign: sign });
            return simplified;
        };

        // Funzione di utilità per ottenere una stringa formattata per un valore frazionario
        const getFractionalDisplayString = (fraction) => {
            if (fraction.denominator === 1) {
                return String(fraction.numerator * fraction.sign);
            }
            // Restituisci il formato di testo semplice per le frazioni
            return `${fraction.sign === -1 ? '-' : ''}${fraction.numerator}/${fraction.denominator}`;
        };

        // Funzione di utilità per analizzare numeri e frazioni, restituendo la rappresentazione frazionaria
        // SPOSTATA FUORI DAL COMPONENTE APP PER L'ACCESSIBILITÀ GLOBALE
        const parseFractionOrNumber = i => {
            let r = String(i).trim();
            let oS = 1; // Original Sign
            const oI = i.trim(); // Original Input

            if (r === '' || r === '(' || r === ')' || r === '[' || r === ']' || r === '{' || r === '}') {
                return {
                    error: `Formato numerico non valido: "${i}".`
                }
            }

            // Controlla il segno iniziale esplicito
            if (r.startsWith('-')) {
                oS = -1;
                r = r.substring(1).trim();
            } else if (r.startsWith('+')) {
                r = r.substring(1).trim();
            }

            let b = 0; // Bilanciamento per le parentesi
            let tLS = []; // Indici della barra di divisione finale

            for (let k = 0; k < r.length; k++) {
                if (r[k] === '(') b++;
                else if (r[k] === ')') b--;
                else if (r[k] === '/' && b === 0) {
                    tLS.push(k)
                }
            }

            if (tLS.length > 1) {
                return {
                    error: `Formato frazionario ambiguo: "${i}". Utilizza le parentesi per chiarire (es. (1/2)/3 o 1/(2/3)).`
                }
            }

            let mSI = tLS.length === 1 ? tLS[0] : -1; // Indice della barra principale
            let fFV; // Valore Frazionario Finale
            let fNV; // Valore Numerico Finale
            let displayObject; // Oggetto per le informazioni di visualizzazione

            if (mSI !== -1) {
                let numeratorString = r.substring(0, mSI).trim(); // Stringa del Numeratore
                let denominatorString = r.substring(mSI + 1).trim(); // Stringa del Denominatore

                // CHIAMATE RICORSIVE per le parti del numeratore e del denominatore
                let parsedNumerator = parseFractionOrNumber(numeratorString);
                if (parsedNumerator.error) return { error: parsedNumerator.error };

                let parsedDenominator = parseFractionOrNumber(denominatorString);
                if (parsedDenominator.error) return { error: parsedDenominator.error };

                if (parsedDenominator.numericValue === 0) {
                    return {
                        error: 'Divisione per zero.'
                    }
                }

                const combinedFraction = divideFractions(parsedNumerator.fractionalValue, parsedDenominator.fractionalValue);
                if (combinedFraction.error) {
                    return { error: combinedFraction.error }
                }

                fFV = simplifyFraction(combinedFraction);
                fFV.sign *= oS;
                fNV = (fFV.numerator / fFV.denominator) * fFV.sign;
                displayObject = { type: 'fraction', ...fFV }; // Usa la frazione semplificata per la visualizzazione
            } else if (r.startsWith('(') && r.endsWith(')')) {
                let iC = r.slice(1, -1).trim(); // Contenuto Interno
                if (iC === '') {
                    return {
                        error: `Contenuto vuoto all'interno delle parentesi: "${i}".`
                    }
                }
                const pI = parseFractionOrNumber(iC); // Interno Analizzato
                if (pI.error) return {
                    error: pI.error
                };
                fFV = pI.fractionalValue;
                fFV.sign *= oS;
                fNV = (fFV.numerator / fFV.denominator) * fFV.sign;
                displayObject = pI.display; // Eredita la visualizzazione dal contenuto interno
                if (displayObject.type === 'fraction') {
                    displayObject.sign = fFV.sign; // Assicura che il segno sia corretto
                } else {
                    displayObject.value = fNV;
                }
            } else {
                const sNR = /^(?:[-+]?\d+(?:\.\d*)?|\.\d+)$/; // Regex per numero semplice, ora consente il segno iniziale
                if (!r.match(sNR)) {
                    return {
                        error: `Formato numerico non valido: "${i}".`
                    }
                }
                const nV = parseFloat(r); // Valore Numerico
                if (isNaN(nV)) {
                    return {
                        error: `Errore interno di parsing per "${i}".`
                    }
                }
                let n = nV; // Numeratore
                let d = 1; // Denominatore
                if (nV % 1 !== 0) {
                    const dP = (nV.toString().split('.')[1] || '').length; // Cifre Decimali
                    d = Math.pow(10, dP);
                    n = Math.round(nV * d)
                }
                fFV = simplifyFraction({
                    numerator: Math.abs(n),
                    denominator: d,
                    sign: (n < 0 ? -1 : 1)
                });
                fFV.sign *= oS;
                fNV = (fFV.numerator / fFV.denominator) * fFV.sign;
                displayObject = { type: 'number', value: fNV };
            }

            let dS; // Stringa di Visualizzazione
            if (fFV.denominator === 1) {
                dS = String(fFV.numerator * fFV.sign)
            } else {
                dS = getFractionalDisplayString(fFV)
            }
            if (fNV === 0 && Object.is(fNV, -0)) {
                dS = "0"
            }

            return {
                type: 'number',
                fractionalValue: fFV,
                numericValue: fNV,
                displayString: dS,
                originalInputString: oI,
                display: displayObject
            }
        };

        // Nuova funzione di aiuto per analizzare una singola stringa di monomio (es. "5x", "-3", "-(2/3)x", "(5)/4")
        // SPOSTATA FUORI DAL COMPONENTE APP PER L'ACCESSIBILITÀ GLOBALE
        const parseMonomialString = (monomialString) => {
            const fullOriginalInput = monomialString; // Memorizza l'originale per la visualizzazione
            let trimmedMonomial = monomialString.trim();
            if (trimmedMonomial === '') {
                throw new Error("Termine monomio vuoto.");
            }

            let effectiveSign = 1;

            // Gestisci il segno iniziale per l'intero monomio
            if (trimmedMonomial.startsWith('-')) {
                effectiveSign = -1;
                trimmedMonomial = trimmedMonomial.substring(1).trim();
            } else if (trimmedMonomial.startsWith('+')) {
                trimmedMonomial = trimmedMonomial.substring(1).trim();
            }

            let coefficientString;
            let hasX = false;

            // Controlla se termina con 'x' (insensibile alle maiuscole)
            const xMatch = trimmedMonomial.match(/^(.*)([xX])$/i);
            if (xMatch) {
                hasX = true;
                coefficientString = xMatch[1].trim(); // Tutto ciò che precede 'x'
                if (coefficientString === '') { // Caso come "x" o "-x" (dopo la rimozione del segno)
                    coefficientString = '1';
                }
            } else {
                coefficientString = trimmedMonomial;
            }

            // --- CONTROLLO DI AMBIGUITÀ PER N/Mx ---
            // Se è un termine X e la stringa del coefficiente contiene un '/',
            // E non è già esplicitamente tra parentesi (es. "(1/2)"),
            // allora è ambiguo.
            // Questo controllo è principalmente per la validazione dell'input dell'utente. Le stringhe generate saranno corrette.
            if (hasX && coefficientString.includes('/') && !(coefficientString.startsWith('(') && coefficientString.endsWith(')'))) {
                throw new Error(`Ambiguità: Il termine '${fullOriginalInput}' contiene una moltiplicazione implicita ambigua come 'N/Mx'. Usa le parentesi per chiarire: '(N/M)*x' o 'N/(M*x)'.`);
            }
            // --- FINE CONTROLLO DI AMBIGUITÀ ---


            // Ora, analizza la stringa del coefficiente che potrebbe essere un numero, una frazione semplice o una frazione tra parentesi
            const parsedCoefficient = parseFractionOrNumber(coefficientString); // Ora chiama la funzione accessibile globalmente

            if (parsedCoefficient.error) {
                throw new Error(`Formato coefficiente non valido per "${coefficientString}" (parte di "${fullOriginalInput}"): ${parsedCoefficient.error}`);
            }

            let finalFractionalValue = parsedCoefficient.fractionalValue;
            finalFractionalValue.sign *= effectiveSign; // Applica il segno complessivo

            const finalNumericValue = (finalFractionalValue.numerator / finalFractionalValue.denominator) * finalFractionalValue.sign;

            return {
                type: hasX ? 'variable' : 'number',
                fractionalValue: finalFractionalValue,
                numericValue: finalNumericValue,
                originalInputString: fullOriginalInput, // Mantieni la stringa originale per la visualizzazione
                display: parsedCoefficient.display // Mantieni le informazioni di visualizzazione originali se necessarie
            };
        };


        // Componente per renderizzare un numero o una frazione in modo coerente
        const ItemDisplay = ({ item }) => {
            // Renderizza il valore principale/coefficiente
            const renderMainValue = () => {
                // Visualizza la stringa di input originale direttamente
                return (
                    <span className="text-xl font-bold">
                        {item.originalInputString}
                    </span>
                );
            };

            // Renderizza il segnale visivo per le operazioni
            const renderVisualCue = () => {
                if (!item.visualCue) return null;

                // item.visualCue.operand è ora la stringa di input originale
                const operandDisplayString = item.visualCue.operand;

                if (item.visualCue.type === 'divide') {
                    return (
                        <div className="flex flex-col items-center justify-center text-sm mt-1">
                            <div className="w-full border-t border-black"></div>
                            <span className="text-black">{operandDisplayString}</span> {/* Usa la stringa direttamente */}
                        </div>
                    );
                } else if (item.visualCue.type === 'multiply') {
                    return (
                        <span className="text-black text-sm mt-1">
                            &middot;&nbsp;{operandDisplayString} {/* Usa la stringa direttamente */}
                        </span>
                    );
                }
                return null;
            };

            return (
                <div className="flex flex-col items-center justify-center h-full w-full">
                    <div className="flex items-center justify-center">
                        {renderMainValue()}
                    </div>
                    {renderVisualCue()}
                </div>
            );
        };

        // Nuovo componente per il rendering del contenuto MathJax
        const MathJaxDisplay = ({ text }) => {
            const ref = React.useRef(null);
            
            React.useEffect(() => {
                if (ref.current && window.MathJax) {
                    window.MathJax.typesetClear([ref.current]);
                    ref.current.innerHTML = text;
                    window.MathJax.typesetPromise([ref.current])
                        .catch(err => console.error("Errore di typesetting MathJax:", err));
                }
            }, [text]);

            return <div ref={ref} />;
        };


        // Funzione per generare una stringa di coefficiente casuale intero o frazionario (può essere zero)
        const generateRandomCoefficient = () => {
            const isFraction = Math.random() < 0.5; // 50% di probabilità per una frazione
            if (isFraction) {
                let num = Math.floor(Math.random() * 21) - 10; // Numeratore tra -10 e 10
                let den = Math.floor(Math.random() * 9) + 2; // Denominatore tra 2 e 10
                const common = gcd(num, den);
                num /= common;
                den /= common;
                if (den < 0) { // Assicura che il denominatore sia positivo
                    num = -num;
                    den = -den;
                }
                // Restituisce la stringa grezza per il coefficiente, che formatCoeffForDisplay userà
                return `${num}/${den}`;
            } else {
                let num = Math.floor(Math.random() * 21) - 10; // Intero tra -10 e 10
                return String(num);
            }
        };

        // Funzione per generare una stringa di coefficiente casuale non zero intero o frazionario
        const generateRandomNonZeroCoefficient = () => {
            let coeff;
            do {
                coeff = generateRandomCoefficient();
                const parsed = parseFractionOrNumber(coeff); // Analizza senza rimuovere le parentesi esterne qui
                if (parsed.error || Math.abs(parsed.numericValue) < 1e-9) { // Controlla errori di parsing o zero effettivo
                    coeff = "0"; // Forza il riavvio
                }
            } while (coeff === "0");
            return coeff;
        };


        // Componente principale dell'App
        const App = () => {
            const { useState, useEffect, useRef, useCallback, useMemo } = React; // Destruttura gli hook di React

            // Un elemento zero per la visualizzazione quando i piatti sono vuoti
            const zeroItem = useMemo(() => ({ type: 'number', fractionalValue: { numerator: 0, denominator: 1, sign: 1 }, numericValue: 0, originalInputString: '0' }), []);

            // Stato per gli elementi sul lato sinistro della bilancia
            const [leftItems, setLeftItems] = useState([]);
            // Stato per gli elementi sul lato destro della bilancia
            const [rightItems, setRightItems] = useState([]);
            // Stato per memorizzare la cronologia per la funzionalità di annullamento
            const [history, setHistory] = useState([]);
            // Stato per memorizzare i messaggi per l'utente (es. stato della bilancia)
            const [message, setMessage] = useState('Benvenuto! Genera un\'equazione per iniziare.');
            // Stato per memorizzare il messaggio dell'equazione risolta (da visualizzare come sovrapposizione)
            const [solvedMessage, setSolvedMessage] = useState(null);
            // Stato per i messaggi di sistema (errori, avvisi)
            const [systemMessage, setSystemMessage] = useState(null);
            // Stato per il valore da aggiungere/rimuovere (per i blocchi numerici)
            const [addNumberValue, setAddNumberValue] = useState('');
            // Stato per il termine X da aggiungere manualmente (es. "2x", "-x")
            const [addXTermValue, setAddXTermValue] = useState('');
            // Stato per il valore da utilizzare nelle operazioni (somma, sottrazione, moltiplicazione, divisione)
            const [opValue, setOpOpValue] = useState('');
            // Stato per il termine da applicare a entrambi i lati per il principio di addizione/sottrazione
            const [applyPrincipleTerm, setApplyPrincipleTerm] = useState('');
            // Stato per l'elemento da rimuovere per valore/termine specifico
            const [removeItemInput, setRemoveItemInput] = useState('');
            // Stato per controllare l'inclinazione della bilancia per il feedback visivo
            const [tilt, setTilt] = useState(0); // -10 per sinistra pesante, 10 per destra pesante, 0 per bilanciato
            // Stato per la stringa di input dell'equazione (solo per riferimento)
            const [equationInput, setEquationInput] = useState('');
            // Stato per tenere traccia del caricamento di MathJax
            const [isMathJaxLoaded, setIsMathJaxLoaded] = useState(false);
            // Stato per tenere traccia del conteggio per il tipo di generazione dell'equazione
            const [generationCount, setGenerationCount] = useState(0);

            // Riferimento all'elemento del braccio per applicare la rotazione
            const beamRef = useRef(null);


            // --- Funzioni di aiuto (Memorizzate per le prestazioni) ---

            const fractionalToString = useCallback((frac) => {
                return getFractionalDisplayString(frac);
            }, []);

            const getSummedComponents = useCallback((items) => {
                let sumNumbersFractional = { numerator: 0, denominator: 1, sign: 1 };
                let sumXFractional = { numerator: 0, denominator: 1, sign: 1 };

                items.forEach(item => {
                    if (!item || !item.fractionalValue || typeof item.fractionalValue.numerator === 'undefined' || typeof item.fractionalValue.denominator === 'undefined' || typeof item.fractionalValue.sign === 'undefined') {
                        console.error("Elemento malformato trovato nel piatto, saltato:", item);
                        return;
                    }
                    if (item.type === 'number') {
                        sumNumbersFractional = addFractions(sumNumbersFractional, item.fractionalValue);
                    } else if (item.type === 'variable') {
                        sumXFractional = addFractions(sumXFractional, item.fractionalValue);
                    }
                });
                return {
                    sumNumbers: (sumNumbersFractional.numerator / sumNumbersFractional.denominator) * sumNumbersFractional.sign,
                    sumX: (sumXFractional.numerator / sumXFractional.denominator) * sumXFractional.sign,
                    sumNumbersFractional: sumNumbersFractional,
                    sumXFractional: sumXFractional
                };
            }, []);

            const processItemsForOperationResult = useCallback((currentItems) => {
                let operationsAppliedLocally = false;
                const updatedItems = currentItems.map(item => {
                    if (item.visualCue) {
                        let newFractionalValue = { ...item.fractionalValue };
                        const operandFractional = item.visualCue.operandFractional;

                        if (item.visualCue.type === 'multiply') {
                            newFractionalValue = simplifyFraction({
                                numerator: newFractionalValue.numerator * operandFractional.numerator,
                                denominator: newFractionalValue.denominator * operandFractional.denominator,
                                sign: newFractionalValue.sign * operandFractional.sign
                            });
                            operationsAppliedLocally = true;
                        } else if (item.visualCue.type === 'divide') {
                            if (operandFractional.numerator === 0) {
                                setSystemMessage('Impossibile dividere per zero durante il calcolo del risultato!');
                                return item;
                            }
                            const divisionResult = divideFractions(newFractionalValue, operandFractional);
                            if (divisionResult.error) {
                                setSystemMessage(divisionResult.error);
                                return item;
                            }
                            newFractionalValue = divisionResult;
                            operationsAppliedLocally = true;
                        }

                        const newNumericValue = (newFractionalValue.numerator / newFractionalValue.denominator) * newFractionalValue.sign;

                        // Aggiorna originalInputString per riflettere il nuovo valore calcolato
                        let newOriginalInputString;
                        if (item.type === 'number') {
                            newOriginalInputString = getFractionalDisplayString(newFractionalValue);
                        } else { // type === 'variable'
                            // Assicura una formattazione corretta per i termini x dopo il calcolo
                            if (newFractionalValue.denominator !== 1 || newNumericValue < 0) {
                                newOriginalInputString = `(${getFractionalDisplayString(newFractionalValue)})x`;
                            } else if (newNumericValue === 1) {
                                newOriginalInputString = 'x';
                            } else if (newNumericValue === -1) {
                                newOriginalInputString = '-x';
                            } else {
                                newOriginalInputString = `${getFractionalDisplayString(newFractionalValue)}x`;
                            }
                        }
                        
                        return {
                            ...item,
                            fractionalValue: newFractionalValue,
                            numericValue: newNumericValue,
                            originalInputString: newOriginalInputString, // Aggiorna questo
                            visualCue: null
                        };
                    }
                    return item;
                });
                return { updatedItems, operationsAppliedLocally };
            }, [getFractionalDisplayString, simplifyFraction, divideFractions]);


            const removeOppositePairs = useCallback((items) => {
                const counts = {};
                const newItems = [];

                items.forEach(item => {
                    const key = `${item.type}-${fractionalToString(item.fractionalValue)}`;
                    counts[key] = (counts[key] || 0) + 1;
                });

                items.forEach(item => {
                    const key = `${item.type}-${fractionalToString(item.fractionalValue)}`;
                    const oppositeFractional = { ...item.fractionalValue, sign: -item.fractionalValue.sign };
                    const oppositeKey = `${item.type}-${fractionalToString(oppositeFractional)}`;

                    if (counts[key] > 0 && counts[oppositeKey] > 0) {
                        counts[key]--;
                        counts[oppositeKey]--;
                    } else if (counts[key] > 0) {
                        newItems.push(item);
                        counts[key]--;
                    }
                });
                return newItems;
            }, [fractionalToString]);

            const sumLikeTerms = useCallback((items) => {
                let sumNumbersFractional = { numerator: 0, denominator: 1, sign: 1 };
                let sumXFractional = { numerator: 0, denominator: 1, sign: 1 };

                items.forEach(item => {
                    if (!item || !item.fractionalValue || typeof item.fractionalValue.numerator === 'undefined' || typeof item.fractionalValue.denominator === 'undefined' || typeof item.fractionalValue.sign === 'undefined') {
                        console.error("Elemento malformato trovato nel piatto durante la somma di termini simili, saltato:", item);
                        return;
                    }
                    if (item.type === 'number') {
                        sumNumbersFractional = addFractions(sumNumbersFractional, item.fractionalValue);
                    } else if (item.type === 'variable') {
                        sumXFractional = addFractions(sumXFractional, item.fractionalValue);
                    }
                });

                const finalItems = [];
                if (sumNumbersFractional.numerator !== 0) {
                    const numericVal = (sumNumbersFractional.numerator / sumNumbersFractional.denominator) * sumNumbersFractional.sign;
                    let originalInputStr = getFractionalDisplayString(sumNumbersFractional);
                    finalItems.push({
                        type: 'number',
                        fractionalValue: sumNumbersFractional,
                        numericValue: numericVal,
                        originalInputString: originalInputStr,
                    });
                }
                if (sumXFractional.numerator !== 0) {
                    const numericVal = (sumXFractional.numerator / sumXFractional.denominator) * sumXFractional.sign;
                    let originalInputStr;
                    // Assicura una formattazione corretta per i termini x dopo la somma
                    if (sumXFractional.denominator !== 1 || numericVal < 0) {
                        originalInputStr = `(${getFractionalDisplayString(sumXFractional)})x`;
                    } else if (numericVal === 1) {
                        originalInputStr = 'x';
                    } else if (numericVal === -1) {
                        originalInputStr = '-x';
                    } else {
                        originalInputStr = `${getFractionalDisplayString(sumXFractional)}x`;
                    }
                    finalItems.push({
                        type: 'variable',
                        fractionalValue: sumXFractional,
                        numericValue: numericVal,
                        originalInputString: originalInputStr,
                    });
                }
                return finalItems;
            }, [getFractionalDisplayString]);


            // --- Logica principale e gestori di eventi ---

            const saveState = useCallback(() => {
                setHistory(prevHistory => [...prevHistory, { left: leftItems, right: rightItems }]);
                setSolvedMessage(null); // Pulisci il messaggio di risoluzione su qualsiasi azione che modifica la bilancia
                setSystemMessage(null); // Pulisci il messaggio di sistema
            }, [leftItems, rightItems]);

            const undoLastAction = useCallback(() => {
                if (history.length > 0) {
                    const previousState = history[history.length - 1];
                    setLeftItems(previousState.left);
                    setRightItems(previousState.right);
                    setHistory(prevHistory => prevHistory.slice(0, -1)); // Rimuovi l'ultimo stato
                    setSystemMessage(null);
                    setMessage('Ultima azione annullata.');
                    setSolvedMessage(null); // Pulisci il messaggio di risoluzione su annullamento
                } else {
                    setSystemMessage('Nessuna azione da annullare.');
                }
            }, [history]);

            const addItemToSide = useCallback((side, item) => {
                saveState(); // Salva lo stato attuale prima della modifica
                if (side === 'left') {
                    setLeftItems(prevItems => {
                        const newItems = [...prevItems];
                        // Rimuovi l'eventuale zeroItem se vengono aggiunti altri elementi
                        const filteredItems = newItems.filter(i => !(i.type === 'number' && i.numericValue === 0 && newItems.length > 0));
                        filteredItems.push(item);
                        return filteredItems;
                    });
                } else {
                    setRightItems(prevItems => {
                        const newItems = [...prevItems];
                        const filteredItems = newItems.filter(i => !(i.type === 'number' && i.numericValue === 0 && newItems.length > 0));
                        filteredItems.push(item);
                        return filteredItems;
                    });
                }
                setSystemMessage(null);
            }, [saveState]);

            const handleAddNumber = useCallback(() => {
                const parsed = parseFractionOrNumber(addNumberValue);
                if (parsed.error) {
                    setSystemMessage(parsed.error + '. Controlla che i valori frazionari siano scritti correttamente.');
                    return;
                }
                addItemToSide('left', { ...parsed, type: 'number' });
                setMessage('Numero aggiunto con successo.');
                setAddNumberValue('');
            }, [addNumberValue, addItemToSide, setSystemMessage, setMessage, setAddNumberValue]);

            const handleAddXTerm = useCallback(() => {
                let inputString = addXTermValue.trim();
                if (inputString === '') {
                    setSystemMessage('Per favor, inserisci un termine X (es. 2x, -x, (1/2)x, -(2/3)x).');
                    return;
                }
                try {
                    const itemToAdd = parseMonomialString(inputString);
                    if (itemToAdd.type !== 'variable') {
                        setSystemMessage('L\'input deve essere un termine X. Controlla il formato.');
                        return;
                    }
                    addItemToSide('left', itemToAdd);
                    setMessage('Termine X aggiunto con successo.');
                    setAddXTermValue('');
                } catch (error) {
                    setSystemMessage(error.message);
                }
            }, [addXTermValue, addItemToSide, setSystemMessage, setMessage, setAddXTermValue]);

            const handleRemoveItem = useCallback((side) => {
                const itemString = removeItemInput.trim();
                if (itemString === '') {
                    setSystemMessage('Per favor, inserisci l\'elemento da rimuovere (es. 5, -3, 2x, -x, (1/2)x).');
                    return;
                }
                try {
                    const itemToMatch = parseMonomialString(itemString);
                    saveState();
                    let itemsToUpdate = side === 'left' ? [...leftItems] : [...rightItems];
                    let removed = false;
                    let newItems = [];

                    for (let i = 0; i < itemsToUpdate.length; i++) {
                        const item = itemsToUpdate[i];
                        if (item.type === itemToMatch.type && fractionalToString(item.fractionalValue) === fractionalToString(itemToMatch.fractionalValue)) {
                            newItems = [...itemsToUpdate.slice(0, i), ...itemsToUpdate.slice(i + 1)];
                            removed = true;
                            break;
                        }
                    }

                    if (removed) {
                        if (side === 'left') {
                            setLeftItems(newItems.length === 0 ? [] : newItems); // Ritorna a un array vuoto
                        } else {
                            setRightItems(newItems.length === 0 ? [] : newItems); // Ritorna a un array vuoto
                        }
                        setSystemMessage(null);
                        setMessage(`Elemento "${itemString}" rimosso dal lato ${side === 'left' ? 'sinistro' : 'destro'}.`);
                    } else {
                        setSystemMessage(`Elemento "${itemString}" non trovato sul lato ${side === 'left' ? 'sinistro' : 'destro'}.`);
                    }
                    setRemoveItemInput('');
                } catch (error) {
                    setSystemMessage(error.message);
                }
            }, [removeItemInput, leftItems, rightItems, saveState, fractionalToString, setLeftItems, setRightItems, setSystemMessage, setMessage, setRemoveItemInput]);

            // Funzione modificata per applicare l'operazione per impostare solo il segnale visivo
            const applyOperation = useCallback((operationType) => {
                const opString = opValue.trim();
                let operandFractionalValue;

                const parsedOp = parseFractionOrNumber(opString);
                if (parsedOp.error) {
                    setSystemMessage(parsedOp.error + '. Controlla che i valori frazionari siano scritti correttamente.');
                    return;
                }
                operandFractionalValue = parsedOp.fractionalValue;
                const visualOperandDisplay = parsedOp.originalInputString; // Usa la stringa originale per il segnale visivo


                if (operationType === 'divide' && operandFractionalValue.numerator === 0) {
                    setSystemMessage('Non puoi dividere per zero!');
                    return;
                }

                saveState(); // Salva lo stato *prima* di applicare il segnale visivo

                const updateItemsWithVisualCue = (currentItems) => {
                    return currentItems.map(item => {
                        let newVisualCue = null;
                        if (operationType === 'multiply') {
                            newVisualCue = { type: 'multiply', operand: visualOperandDisplay, operandFractional: operandFractionalValue };
                        } else if (operationType === 'divide') {
                            newVisualCue = { type: 'divide', operand: visualOperandDisplay, operandFractional: operandFractionalValue };
                        }
                        return {
                            ...item,
                            visualCue: newVisualCue
                        };
                    });
                };

                setLeftItems(prevItems => updateItemsWithVisualCue(prevItems));
                setRightItems(prevItems => updateItemsWithVisualCue(prevItems));

                setSystemMessage(null);
                setMessage(`Operazione di ${operationType} per ${opString} applicata ad entrambi i lati (visualizzato). Clicca "Calcola Moltiplicazione/Divisione" per applicare il risultato.`);
                setOpOpValue('');
            }, [opValue, saveState, setSystemMessage, setMessage, setOpOpValue, setLeftItems, setRightItems]);


            const applyAdditionSubtractionPrinciple = useCallback(() => {
                const termString = applyPrincipleTerm.trim();
                if (termString === '') {
                    setSystemMessage('Per favor, inserisci un termine (es. +5, -2x).');
                    return;
                }
                try {
                    const itemToAdd = parseMonomialString(termString);
                    saveState();

                    const addWithProximity = (currentItems, newItem) => {
                        const newItems = [...currentItems];
                        // Filtra l'eventuale elemento zero se esistono altri elementi
                        const filteredItems = newItems.filter(i => !(i.type === 'number' && i.numericValue === 0 && newItems.length > 1));

                        let inserted = false;
                        for (let i = 0; i < filteredItems.length; i++) {
                            const existingItem = filteredItems[i];
                            // Controlla l'opposto per tipo e valore (confronto approssimato per i float)
                            if (existingItem.type === newItem.type && Math.abs(existingItem.numericValue + newItem.numericValue) < 1e-9) {
                                filteredItems.splice(i + 1, 0, { ...newItem }); // Inserisci dopo l'opposto
                                inserted = true;
                                break;
                            }
                        }
                        if (!inserted) {
                            filteredItems.push({ ...newItem }); // Se non c'è l'opposto, aggiungi semplicemente alla fine
                        }
                        return filteredItems;
                    };

                    setLeftItems(prevItems => {
                        const newItems = addWithProximity(prevItems, itemToAdd);
                        return newItems.length === 0 ? [] : newItems;
                    });
                    setRightItems(prevItems => {
                        const newItems = addWithProximity(prevItems, itemToAdd);
                        return newItems.length === 0 ? [] : newItems;
                    });

                    setSystemMessage(null);
                    setMessage(`Aggiunto "${itemToAdd.originalInputString}" ad entrambi i lati.`);
                    setApplyPrincipleTerm('');
                } catch (error) {
                    setSystemMessage(error.message);
                }
            }, [applyPrincipleTerm, saveState, setSystemMessage, setMessage, setApplyPrincipleTerm, setLeftItems, setRightItems]);

            const handleRemoveOpposites = useCallback(() => {
                saveState();
                const newLeftItems = removeOppositePairs(leftItems);
                const newRightItems = removeOppositePairs(rightItems);

                setLeftItems(newLeftItems.length === 0 ? [] : newLeftItems);
                setRightItems(newRightItems.length === 0 ? [] : newRightItems);

                if (newLeftItems.length === leftItems.length && newRightItems.length === rightItems.length) {
                    setSystemMessage('Nessuna coppia opposta trovata da eliminare.');
                } else {
                    setSystemMessage(null);
                    setMessage('Coppie opposte eliminate da entrambi i lati!');
                }
            }, [leftItems, rightItems, saveState, removeOppositePairs, setLeftItems, setRightItems, setSystemMessage, setMessage]);

            const handleSumLikeTerms = useCallback(() => {
                saveState();
                const newLeftItems = sumLikeTerms(leftItems);
                const newRightItems = sumLikeTerms(rightItems);

                // Controlla se è avvenuto un cambiamento effettivo per evitare messaggi/aggiornamenti di stato non necessari
                const leftChanged = JSON.stringify(newLeftItems.map(i => ({ val: fractionalToString(i.fractionalValue), type: i.type }))) !== JSON.stringify(leftItems.map(i => ({ val: fractionalToString(i.fractionalValue), type: i.type })));
                const rightChanged = JSON.stringify(newRightItems.map(i => ({ val: fractionalToString(i.fractionalValue), type: i.type }))) !== JSON.stringify(rightItems.map(i => ({ val: fractionalToString(i.fractionalValue), type: i.type })));

                if (!leftChanged && !rightChanged) {
                    setSystemMessage('Nessun termine simile da sommare o già sommati.');
                } else {
                    setLeftItems(newLeftItems.length === 0 ? [] : newLeftItems);
                    setRightItems(newRightItems.length === 0 ? [] : newRightItems);
                    setSystemMessage(null);
                    setMessage('Monomi simili sommati su entrambi i lati!');
                }
            }, [leftItems, rightItems, saveState, sumLikeTerms, fractionalToString, setLeftItems, setRightItems, setSystemMessage, setMessage]);

            const calculateOperationResult = useCallback(() => {
                saveState();

                const { updatedItems: newLeftItems, operationsAppliedLocally: leftOpsApplied } = processItemsForOperationResult(leftItems);
                const { updatedItems: newRightItems, operationsAppliedLocally: rightOpsApplied } = processItemsForOperationResult(rightItems);

                setLeftItems(newLeftItems.length === 0 ? [] : newLeftItems);
                setRightItems(newRightItems.length === 0 ? [] : newRightItems);

                if (leftOpsApplied || rightOpsApplied) {
                    setSystemMessage(null);
                    setMessage('Risultato delle operazioni di moltiplicazione/divisione calcolato!');
                } else {
                    setSystemMessage('Nessuna operazione di moltiplicazione/divisione in sospeso da calcolare.');
                }
            }, [leftItems, rightItems, saveState, processItemsForOperationResult, setLeftItems, setRightItems, setSystemMessage, setMessage]);


            const analyzeFinalEquation = useCallback(() => {
                setSystemMessage(null);
                // Pulisci inizialmente il messaggio di risoluzione per assicurarti che appaia solo se l'analisi ha successo
                setSolvedMessage(null); 

                const leftComponents = getSummedComponents(leftItems);
                const rightComponents = getSummedComponents(rightItems);

                const combinedXFractional = addFractions(leftComponents.sumXFractional, {
                    numerator: rightComponents.sumXFractional.numerator,
                    denominator: rightComponents.sumXFractional.denominator,
                    sign: -rightComponents.sumXFractional.sign
                });
                const combinedNumbersFractional = addFractions(rightComponents.sumNumbersFractional, {
                    numerator: leftComponents.sumNumbersFractional.numerator,
                    denominator: leftComponents.sumNumbersFractional.denominator,
                    sign: -leftComponents.sumNumbersFractional.sign
                });

                const combinedX = (combinedXFractional.numerator / combinedXFractional.denominator) * combinedXFractional.sign;
                const combinedNumbers = (combinedNumbersFractional.numerator / combinedNumbersFractional.denominator) * combinedNumbersFractional.sign;

                const isCombinedXZero = Math.abs(combinedX) < 1e-9;
                const isCombinedNumbersZero = Math.abs(combinedNumbers) < 1e-9;

                let analysisType = null;
                let solutionDisplay = null;

                if (!isCombinedXZero) {
                    const solutionFractional = divideFractions(combinedNumbersFractional, combinedXFractional);
                    if (solutionFractional.error) {
                        analysisType = 'error';
                        solutionDisplay = solutionFractional.error;
                        setSystemMessage(`Errore durante l'analisi dell'equazione: ${solutionDisplay}`);
                    } else {
                        const solutionValue = (solutionFractional.numerator / solutionFractional.denominator) * solutionFractional.sign;

                        if (solutionFractional.denominator === 1) {
                            solutionDisplay = solutionValue.toString();
                        } else {
                            solutionDisplay = `${solutionFractional.sign === -1 ? '-' : ''}${solutionFractional.numerator}/${solutionFractional.denominator}`;
                        }
                        analysisType = 'determined';
                        setSystemMessage(null);
                    }
                } else if (isCombinedXZero && !isCombinedNumbersZero) {
                    const displayNum = combinedNumbersFractional.denominator === 1 ?
                                       combinedNumbersFractional.sign * combinedNumbersFractional.numerator :
                                       `${combinedNumbersFractional.sign === -1 ? '-' : ''}${combinedNumbersFractional.numerator}/${combinedNumbersFractional.denominator}`;
                    solutionDisplay = displayNum;
                    analysisType = 'impossible';
                    setSystemMessage(null);
                } else if (isCombinedXZero && isCombinedNumbersZero) {
                    analysisType = 'indeterminate';
                    setSystemMessage(null);
                } else {
                    // Questo caso non dovrebbe essere raggiunto se le condizioni precedenti coprono tutte le possibilità
                    setSolvedMessage(null);
                }

                if (analysisType === 'determined') {
                    setSolvedMessage(
                        <p className="text-black">
                            Equazione risolta!<br />X = {solutionDisplay}<br />Equazione determinata.
                        </p>
                    );
                } else if (analysisType === 'impossible') {
                    setSolvedMessage(
                        <p className="text-black">
                            Equazione Impossibile!<br />0 = {solutionDisplay}<br />(Numero = Numero Diverso)
                        </p>
                    );
                } else if (analysisType === 'indeterminate') {
                    setSolvedMessage(
                        <p className="text-black">
                            Equazione INDETERMINATA!<br />0 = 0<br />(Numero = Numero)
                        </p>
                    );
                } else if (analysisType === 'error') {
                    // Il messaggio è già impostato da setSystemMessage sopra
                    setSolvedMessage(null); // Assicurati che non ci sia un messaggio di risoluzione in caso di errore
                }
            }, [leftItems, rightItems, getSummedComponents, setSolvedMessage, setSystemMessage]);

            const generateNewEquation = useCallback(() => {
                setGenerationCount(prevCount => prevCount + 1);
                let eqString = "";
                let a_coeff, b_coeff, c_coeff, d_coeff;

                // Funzione di aiuto per formattare una stringa di coefficiente per la visualizzazione nella stringa dell'equazione
                const formatCoeffForDisplay = (coeffString, isXTerm = false) => {
                    const parsed = parseFractionOrNumber(coeffString);
                    if (parsed.error) return coeffString; // Fallback

                    let display = parsed.displayString; // es. "5", "-2", "1/2", "-3/4"

                    if (isXTerm) {
                        // Gestisci i casi '1x' e '-1x' per una visualizzazione più pulita
                        if (parsed.numericValue === 1) return 'x';
                        if (parsed.numericValue === -1) return '-x';

                        // Se è una frazione o un numero negativo, avvolgi il coefficiente tra parentesi
                        if (parsed.fractionalValue.denominator !== 1 || parsed.numericValue < 0) {
                            display = `(${display})`;
                        }
                        return `${display}x`;
                    } else {
                        // Per i termini costanti, restituiscili con il loro segno.
                        return display;
                    }
                };

                // Funzione di aiuto per determinare se un termine necessita di un prefisso '+' e formattarlo
                const getTermWithSign = (coeffString, isXTerm = false, isFirstTerm = false) => {
                    const parsed = parseFractionOrNumber(coeffString);
                    if (parsed.error) return coeffString; // Fallback

                    const formatted = formatCoeffForDisplay(coeffString, isXTerm);

                    if (parsed.numericValue >= 0 && !isFirstTerm) {
                        return `+ ${formatted}`;
                    } else if (parsed.numericValue < 0 && isXTerm && parsed.fractionalValue.denominator === 1) {
                         // Per i termini x interi negativi, il segno fa parte della stringa formattata, nessun spazio aggiuntivo
                        return formatted;
                    } else {
                        // Per i numeri negativi o i termini x frazionari negativi, il segno fa parte della stringa formattata
                        return formatted;
                    }
                };


                // Determina il tipo di equazione in base al conteggio
                // Priorità: Indeterminata > Impossibile > Determinata
                if ((generationCount + 1) % 3 === 0) { // Indeterminata
                    do {
                        a_coeff = generateRandomNonZeroCoefficient(); // Assicura che 'a' sia non zero per la presenza di 'x'
                    } while (false); // Loopa solo una volta poiché generateRandomNonZeroCoefficient assicura non zero
                    c_coeff = a_coeff; // Indeterminata: ax + b = ax + b
                    b_coeff = generateRandomCoefficient();
                    d_coeff = b_coeff;

                    eqString = `${getTermWithSign(a_coeff, true, true)} ${getTermWithSign(b_coeff, false)}`;
                    eqString += ` = ${getTermWithSign(c_coeff, true, true)} ${getTermWithSign(d_coeff, false)}`;
                    setMessage('Equazione Indeterminata generata. (Infinite soluzioni)');
                } else if ((generationCount + 1) % 2 === 0) { // Impossibile
                    do {
                        a_coeff = generateRandomNonZeroCoefficient(); // Assicura che 'a' sia non zero per la presenza di 'x'
                    } while (false);
                    c_coeff = a_coeff; // Impossibile: ax + b = ax + d (b != d)
                    b_coeff = generateRandomCoefficient();
                    d_coeff = generateRandomCoefficient();
                    while (b_coeff === d_coeff) { // Assicura che b != d
                        d_coeff = generateRandomCoefficient();
                    }
                    eqString = `${getTermWithSign(a_coeff, true, true)} ${getTermWithSign(b_coeff, false)}`;
                    eqString += ` = ${getTermWithSign(c_coeff, true, true)} ${getTermWithSign(d_coeff, false)}`;
                    setMessage('Equazione Impossibile generata. (Nessuna soluzione)');
                } else { // Determinata
                    do {
                        a_coeff = generateRandomCoefficient();
                        c_coeff = generateRandomCoefficient();
                        const parsedA = parseFractionOrNumber(a_coeff);
                        const parsedC = parseFractionOrNumber(c_coeff);
                        // Assicura che a != c E che almeno uno tra a o c sia non zero
                        if (Math.abs(parsedA.numericValue - parsedC.numericValue) > 1e-9 && (Math.abs(parsedA.numericValue) > 1e-9 || Math.abs(parsedC.numericValue) > 1e-9)) {
                            break;
                        }
                    } while (true);
                    b_coeff = generateRandomCoefficient();
                    d_coeff = generateRandomCoefficient();
                    
                    eqString = `${getTermWithSign(a_coeff, true, true)} ${getTermWithSign(b_coeff, false)}`;
                    eqString += ` = ${getTermWithSign(c_coeff, true, true)} ${getTermWithSign(d_coeff, false)}`;
                    setMessage('Equazione Determinata generata. (Una soluzione)');
                }

                // Pulisci i segni '+' iniziali se presenti e gli spazi doppi
                eqString = eqString.replace(/^\+\s*/, '').replace(/=\s*\+\s*/, '= ').replace(/\s{2,}/g, ' ').trim();

                setEquationInput(eqString); // Rimuovi gli spazi extra
                // Pulisci i piatti per forzare l'inserimento manuale per la nuova equazione
                setLeftItems([]);
                setRightItems([]);
                setHistory([]);
                setSolvedMessage(null);
                setTilt(0);
                setSystemMessage(null);
            }, [generationCount, setGenerationCount, setEquationInput, setMessage, setLeftItems, setRightItems, setHistory, setSolvedMessage, setTilt, setSystemMessage]);


            const clearAll = useCallback(() => {
                saveState();
                setLeftItems([]);
                setRightItems([]);
                setAddNumberValue('');
                setAddXTermValue('');
                setOpOpValue('');
                setApplyPrincipleTerm('');
                setRemoveItemInput('');
                setSystemMessage(null);
                setSolvedMessage(null); // Pulisci il messaggio di risoluzione
                setTilt(0);
                setHistory([]); // Pulisci la cronologia quando si resetta completamente
                generateNewEquation(); // Genera una nuova equazione
            }, [saveState, setLeftItems, setRightItems, setAddNumberValue, setAddXTermValue, setOpOpValue, setApplyPrincipleTerm, setRemoveItemInput, setSystemMessage, setSolvedMessage, setTilt, setHistory, generateNewEquation]);


            // --- Hook per gli Effetti ---

            // Generazione iniziale al montaggio del componente
            useEffect(() => {
                generateNewEquation();
            }, []); // L'array vuoto di dipendenze significa che viene eseguito una volta al montaggio

            // Effetto per rivalutare lo stato della bilancia ogni volta che gli elementi cambiano
            useEffect(() => {
                // Funzione di aiuto per ottenere i componenti X e Numerici sommati per un dato array di elementi
                const getSummedComponentsLocal = (items) => {
                    let sumNumbersFractional = { numerator: 0, denominator: 1, sign: 1 };
                    let sumXFractional = { numerator: 0, denominator: 1, sign: 1 };

                    items.forEach(item => {
                        if (item.type === 'number') {
                            sumNumbersFractional = addFractions(sumNumbersFractional, item.fractionalValue);
                        } else if (item.type === 'variable') {
                            sumXFractional = addFractions(sumXFractional, item.fractionalValue);
                        }
                    });
                    return {
                        sumNumbers: (sumNumbersFractional.numerator / sumNumbersFractional.denominator) * sumNumbersFractional.sign,
                        sumX: (sumXFractional.numerator / sumXFractional.denominator) * sumXFractional.sign,
                        sumNumbersFractional: sumNumbersFractional,
                        sumXFractional: sumXFractional
                    };
                };

                let newTilt;
                let newMainMessage = ''; // Questo memorizzerà il messaggio in base allo stato della bilancia

                const leftComponents = getSummedComponentsLocal(leftItems);
                const rightComponents = getSummedComponentsLocal(rightItems);

                const leftTotalNumeric = leftComponents.sumNumbers + leftComponents.sumX;
                const rightTotalNumeric = rightComponents.sumNumbers + rightComponents.sumX;

                if (Math.abs(leftTotalNumeric - rightTotalNumeric) < 1e-9) {
                    newMainMessage = 'Le espressioni sui piatti hanno lo stesso "peso" simbolico.';
                    newTilt = 0;
                } else if (leftTotalNumeric < rightTotalNumeric) {
                    newMainMessage = 'Il lato sinistro ha un "peso" simbolico minore.';
                    newTilt = -10;
                } else {
                    newMainMessage = 'Il lato destro ha un "peso" simbolico minore.';
                    newTilt = 10;
                }

                // Se i piatti sono vuoti dopo le operazioni, riaggiungi l'elemento zero per la visualizzazione
                if (leftItems.length === 0) {
                    setLeftItems([zeroItem]);
                }
                if (rightItems.length === 0) {
                    setRightItems([zeroItem]);
                }
                
                // Aggiorna il messaggio principale solo se non c'è un messaggio di sistema (errore/avviso)
                // o se è il messaggio di caricamento iniziale.
                // Altrimenti, lascia che il messaggio impostato da generateNewEquation o altre azioni persista.
                if (systemMessage === null) {
                    // Aggiorna solo se il messaggio attuale è generico, non un messaggio del tipo di equazione
                    // o se è il primissimo caricamento.
                    if (message.includes('Benvenuto!') || message.includes('Bilancia azzerata!') || newMainMessage !== message) {
                        setMessage(newMainMessage);
                    }
                }
                
                setTilt(newTilt);

                if (beamRef.current) {
                    beamRef.current.style.setProperty('--current-tilt', `${newTilt}deg`);

                    const shouldJiggle = (Math.abs(newTilt) > 0); // Scuoti sempre se non è bilanciato
                    if (shouldJiggle) {
                        beamRef.current.classList.add('jiggle-animation');
                        const timer = setTimeout(() => {
                            if (beamRef.current) {
                                beamRef.current.classList.remove('jiggle-animation');
                            }
                        }, 300);
                        return () => clearTimeout(timer);
                    } else {
                        beamRef.current.classList.remove('jiggle-animation');
                    }
                }
            }, [leftItems, rightItems, systemMessage, setMessage, setTilt, zeroItem, message]);

            // Effetto per gestire il caricamento di MathJax
            useEffect(() => {
                const checkMathJax = () => {
                    if (window.MathJax && window.MathJax.startup && window.MathJax.startup.promise) {
                        window.MathJax.startup.promise.then(() => {
                            setIsMathJaxLoaded(true);
                            window.MathJax.typesetPromise();
                        }).catch(err => console.error("Errore di typesetting MathJax:", err));
                    } else {
                        setTimeout(checkMathJax, 100);
                    }
                };
                checkMathJax();
            }, []);


            // --- Logica di rendering ---

            // Tutti i controlli sono sempre abilitati poiché l'app è sempre in modalità 'risoluzione'
            const areSolvingControlsEnabled = true;


            return (
                <div className="min-h-screen bg-gradient-to-br from-rose-50 to-rose-200 flex flex-col items-center justify-center p-4 font-inter">
                    <h1 className="text-4xl font-extrabold text-gray-800 mb-4 text-center drop-shadow-md">
                        Bilancia Algebrica con Equazione Assegnata
                    </h1>

                    {/* Visualizzazione dei messaggi (stato generale) */}
                    <div className="text-xl font-semibold text-gray-700 mb-6 p-3 bg-white rounded-lg shadow-md">
                        <MathJaxDisplay text={message} />
                    </div>
                    <p className="text-sm text-black mb-6 text-center">
                        La bilancia si inclina in modo che il lato con il "peso" simbolico maggiore si abbassi e il lato più leggero si alzi.
                    </p>

                    {/* Visualizzazione dei messaggi di sistema (per errori/feedback critico) */}
                    {systemMessage && (
                        <div className="text-xl font-bold text-red-800 mb-6 p-4 bg-red-200 rounded-lg shadow-md text-center w-full max-w-4xl">
                            <MathJaxDisplay text={systemMessage} />
                        </div>
                    )}

                    {/* Sezione di input dell'equazione (solo per riferimento) */}
                    <div className="control-section max-w-2xl">
                        <div className="flex items-center mb-3">
                            <h3 className="text-center text-xl font-bold text-gray-700 mr-2 whitespace-nowrap">
                                Equazione da risolvere:
                            </h3>
                            <input
                                type="text"
                                value={equationInput}
                                readOnly // Rendi di sola lettura
                                className="flex-1 p-2 border border-rose-300 rounded-md bg-gray-100 cursor-not-allowed"
                            />
                        </div>
                        <button onClick={generateNewEquation} className="w-full bg-rose-200 hover:bg-rose-300 text-black">
                            Genera Nuova Equazione
                        </button>
                        <p className="text-sm text-gray-600 mt-3 text-center">
                            Usa questa equazione come riferimento. Aggiungi i termini ai piatti manualmente.
                        </p>
                    </div>

                    <div className="balance-container">
                        <div className="pivot"></div>
                        <div className="pivot-base"></div>
                        <div className="beam" ref={beamRef} style={{ transform: `rotate(${tilt}deg)` }}> {/* Riferimento per la rotazione */}
                            <div className="plate-holder">
                                <div className="plate">
                                    {leftItems.length > 0 ? (
                                        leftItems.map((item, index) => (
                                            <div key={`left-${index}`} className={`item-block ${item.type === 'variable' ? 'variable' : (item.numericValue >= 0 ? 'positive' : 'negative')}`}>
                                                <ItemDisplay item={item} />
                                            </div>
                                        ))
                                    ) : (
                                        <div className="item-block positive">
                                            <ItemDisplay item={zeroItem} />
                                        </div>
                                    )}
                                </div>
                            </div>
                            <div className="plate-holder">
                                <div className="plate">
                                    {rightItems.length > 0 ? (
                                        rightItems.map((item, index) => (
                                            <div key={`right-${index}`} className={`item-block ${item.type === 'variable' ? 'variable' : (item.numericValue >= 0 ? 'positive' : 'negative')}`}>
                                                <ItemDisplay item={item} />
                                            </div>
                                        ))
                                    ) : (
                                        <div className="item-block positive">
                                            <ItemDisplay item={zeroItem} />
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>
                        {/* Sovrapposizione del messaggio di risoluzione */}
                        {solvedMessage && (
                            <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-rose-200 text-black text-lg font-bold p-4 rounded-lg shadow-xl z-20 text-center">
                                {solvedMessage}
                            </div>
                        )}
                    </div>


                    <div className="flex flex-col gap-6 w-full max-w-6xl">
                        {/* Sezione consolidata per l'aggiunta/rimozione di elementi */}
                        {areSolvingControlsEnabled && (
                            <div className="control-section max-w-6xl">
                                <h3 className="mb-4">Aggiungi Elementi Manualmente</h3>
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-x-12 gap-y-4">
                                    <div className="flex items-center justify-between gap-2">
                                        <span className="text-lg font-semibold text-gray-600 w-32 flex-shrink-0 whitespace-nowrap">Numero:</span>
                                        <button onClick={() => handleAddNumber('left')} className="flex-initial w-28 bg-rose-200 hover:bg-rose-300 text-black">
                                            Aggiungi Sinistra
                                        </button>
                                        <input
                                            type="text"
                                            placeholder="Es. 5, -3, 1/2"
                                            value={addNumberValue}
                                            onChange={(e) => setAddNumberValue(e.target.value)}
                                            className="flex-1 p-2 border border-rose-300 rounded-md focus:ring-2 focus:ring-rose-400 mx-2"
                                        />
                                        <button onClick={() => handleAddNumber('right')} className="flex-initial w-28 bg-rose-200 hover:bg-rose-300 text-black">
                                            Aggiungi Destra
                                        </button>
                                    </div>

                                    <div className="flex items-center justify-between gap-2">
                                        <span className="text-lg font-semibold text-gray-600 w-32 flex-shrink-0 whitespace-nowrap">Termine X:</span>
                                        <button onClick={() => handleAddXTerm('left')} className="flex-initial w-28 bg-rose-200 hover:bg-rose-300 text-black">
                                            Aggiungi Sinistra
                                        </button>
                                        <input
                                            type="text"
                                            placeholder="Es. 2x, -x, (1/2)x, -(2/3)x"
                                            value={addXTermValue}
                                            onChange={(e) => setAddXTermValue(e.target.value)}
                                            className="flex-1 p-2 border border-rose-300 rounded-md focus:ring-2 focus:ring-rose-400 mx-2"
                                        />
                                        <button onClick={() => handleAddXTerm('right')} className="flex-initial w-28 bg-rose-200 hover:bg-rose-300 text-black">
                                            Aggiungi Destra
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Nuova sezione per la rimozione di elementi specifici */}
                        {areSolvingControlsEnabled && (
                            <div className="control-section max-w-lg">
                                <h3 className="mb-4">Rimuovi Elementi Specifici</h3>
                                <div className="flex items-center justify-between gap-2">
                                    <span className="text-lg font-semibold text-gray-600 w-32 flex-shrink-0 whitespace-nowrap">Rimuovi:</span>
                                    <button onClick={() => handleRemoveItem('left')} className="flex-initial w-28 bg-rose-200 hover:bg-rose-300 text-black">
                                        Rimuovi Sinistra
                                    </button>
                                    <input
                                        type="text"
                                        placeholder="Es. 5, -3, 2x, -x, (1/2)x"
                                        value={removeItemInput}
                                        onChange={(e) => setRemoveItemInput(e.target.value)}
                                        className="flex-1 p-2 border border-rose-300 rounded-md focus:ring-2 focus:ring-rose-400 mx-2"
                                    />
                                    <button onClick={() => handleRemoveItem('right')} className="flex-initial w-28 bg-rose-200 hover:bg-rose-300 text-black">
                                        Rimuovi Destra
                                    </button>
                                </div>
                            </div>
                        )}

                        {/* Nuova riga per le sezioni dei principi */}
                        {areSolvingControlsEnabled && (
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                {/* Applica il Principio di Addizione/Sottrazione */}
                                <div className="control-section">
                                    <h3>Applica il 1° Principio di Equivalenza delle Equazioni (Addizione/Sottrazione)</h3>
                                    <input
                                        type="text"
                                        placeholder="Termine da aggiungere (es. +5, -2x)"
                                        value={applyPrincipleTerm}
                                        onChange={(e) => setApplyPrincipleTerm(e.target.value)}
                                        className="w-full p-2 border border-rose-300 rounded-md focus:ring-2 focus:ring-rose-400 mb-3"
                                    />
                                    <button onClick={applyAdditionSubtractionPrinciple} className="w-full bg-rose-200 hover:bg-rose-300 text-black">
                                        Aggiungi questo termine a entrambi i lati
                                    </button>
                                    <p className="text-sm text-gray-600 mt-3">
                                        Questo aggiungerà il termine esattamente come inserito a entrambi i piatti.
                                    </p>
                                </div>

                                {/* Applica le operazioni (Moltiplicazione/Divisione) */}
                                <div className="control-section">
                                    <h3>Applica il 2° Principio di Equivalenza delle Equazioni (Moltiplicazione/Divisione)</h3>
                                    <div className="flex flex-col items-center gap-2">
                                        <input
                                            type="text"
                                            placeholder="Valore (es. 2, 0.5, 1/2, -3/4)"
                                            value={opValue}
                                            onChange={(e) => setOpOpValue(e.target.value)}
                                            className="w-full p-2 border border-rose-300 rounded-md focus:ring-2 focus:ring-rose-400 mb-3"
                                        />
                                        <div className="grid grid-cols-2 gap-3 w-full">
                                            <button onClick={() => applyOperation('multiply')} className="bg-rose-200 hover:bg-rose-300 text-black">
                                                Moltiplica entrambi i lati
                                            </button>
                                            <button onClick={() => applyOperation('divide')} className="bg-rose-200 hover:bg-rose-300 text-black">
                                                Dividi entrambi i lati
                                            </button>
                                        </div>
                                    </div>
                                    <p className="text-sm text-gray-600 mt-3">
                                        Queste operazioni si applicano a tutti i termini sui piatti.
                                    </p>
                                </div>
                            </div>
                        )}
                    </div>

                    {/* Pulsanti di azione globale */}
                    <div className="flex flex-wrap justify-center gap-4 mt-8 w-full max-w-full">
                        <button onClick={handleRemoveOpposites} className="bg-gradient-to-r from-rose-300 to-rose-400 hover:from-rose-400 hover:to-rose-500 text-black font-bold py-4 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 flex-1 min-w-[180px]">
                            Elimina Coppie Opposte
                        </button>
                        <button onClick={handleSumLikeTerms} className="bg-gradient-to-r from-pink-400 to-rose-500 hover:from-pink-500 hover:to-rose-600 text-black font-bold py-4 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 flex-1 min-w-[180px]">
                            Somma Algebrica di Monomi Simili
                        </button>
                        <button onClick={calculateOperationResult} className="bg-gradient-to-r from-rose-300 to-pink-400 hover:from-rose-400 hover:to-pink-500 text-black font-bold py-4 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 flex-1 min-w-[180px]">
                            Calcola Moltiplicazione/Divisione
                        </button>
                        <button onClick={analyzeFinalEquation} className="bg-gradient-to-r from-rose-400 to-red-500 hover:from-rose-500 hover:to-red-600 text-black font-bold py-4 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 flex-1 min-w-[180px]">
                            Analizza Soluzione Finale
                        </button>
                        <button onClick={undoLastAction} className="bg-gradient-to-r from-red-400 to-rose-500 hover:from-red-500 hover:to-rose-600 text-black font-bold py-4 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 flex-1 min-w-[180px]" disabled={history.length === 0}>
                            Annulla Ultima Azione
                        </button>
                    </div>

                    <button onClick={clearAll} className="mt-4 bg-gradient-to-r from-red-300 to-rose-400 hover:from-red-400 hover:to-rose-500 text-black font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105">
                        Azzera Bilancia
                    </button>
                </div>
            );
        };

        // Usa window.onload per assicurarti che tutti gli script e il DOM siano caricati
        window.onload = function() {
            if (window.ReactDOM) {
                window.ReactDOM.createRoot(document.getElementById('root')).render(<App />);
            } else {
                console.error("ReactDOM non caricato correttamente. Controlla i tag script CDN.");
            }
        };
    </script>
</body>
</html>
